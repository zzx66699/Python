# Chapter6 数据分组、透视
## 分组 .groupby()
df.groupby('按照xx分组的列')['要进行操作的列'].操作方式()  

查看详细的分组情况  

``` python
df.groupby('items').groups
```
<img width="490" alt="image" src="https://user-images.githubusercontent.com/105503216/184536696-186de841-5fd3-4eee-b7cb-f406fae06740.png">  

如果不写‘要进行操作的列’ 则对所有数据型变量都进行操作

``` python
df.groupby('items').mean()
```
<img width="223" alt="image" src="https://user-images.githubusercontent.com/105503216/184536819-e643aa1f-e613-4c8b-92e4-c648742a6729.png">  

### 把聚类之后的结果赋值给原表 - to_dict & map

``` python
dic = df.groupby('color')['weight'].mean().to_dict()   # 求完mean之后是一个series 通过to_dict()变成dic
df['mean_w'] = df['color'].map(dic)  # map之前需要匹配的列 就是分组的依据的列
df
```
<img width="365" alt="image" src="https://user-images.githubusercontent.com/105503216/184537320-49f38ef5-bf06-44e6-846f-b2371fd698b6.png">   


EXAMPLE:  
``` python
n = nowcoder.groupby('date')['question_id'].count()    # 一定要加数xxx
```

根据两个条件分组  

``` python
nowcoder['year-month-day']= pd.to_datetime(nowcoder['date']).dt.date
df = nowcoder.groupby(['result','year-month-day'])['year-month-day'].count()
print(df)
```
<img width="397" alt="image" src="https://user-images.githubusercontent.com/105503216/183256387-856b23cd-87e0-4d9a-a15b-2ce6ca28557e.png">

``` python
 print(df.index)     # df是series 并且是不显示根据某一列数的那一列！！！！
 ```
 <img width="560" alt="image" src="https://user-images.githubusercontent.com/105503216/183276324-e4508f63-1b4c-4c67-8987-eed70bad384d.png">  
 
 
 ### 当我们需要显示根据那列的列名的时候 注意用[[]] 
 ``` python
 ct = df.groupby(['sex','department','item_name'])[['employee_id']].count()
 print(ct)
```
<img width="291" alt="image" src="https://user-images.githubusercontent.com/105503216/183337726-dac7eb16-a522-415b-b85a-e54bd72425a9.png">  

此时ct是一个dataframe   
<img width="970" alt="image" src="https://user-images.githubusercontent.com/105503216/183337794-115169d3-a17b-4777-bce2-25175b079ba4.png">  

### 分组之后求unique值的数量
.nunique()

``` python
cnt = df2.groupby('shopid')['itemid'].nunique()
```

## unstack() 把inner layer变成column
``` python
ct = df.groupby(['sex','department','item_name'])[['employee_id']].count().unstack()
print(ct)
```
<img width="305" alt="image" src="https://user-images.githubusercontent.com/105503216/183338199-f76bd7f5-3a74-44d7-acd0-9113e0eca988.png">  


## 自定义聚合运算的形式
### aggregate 每一组只输出一个值 所以输出的行数=组别数
**单一column分组 单一column中对应的mean和std**  
1.普通写法
``` python
# 找出每一个unique值 -- 分别做出subset -- 求mean和std -- 合并
mean = []
std = [] 
for segment in data['segment'].unique():            # Iterate all values of segments
    subset = data.loc[data['segment'] == segment]   # Take a subset for one segment
    means.append(subset['price'].mean())            # Append the mean of the subset
    stds.append(subset['price'].std())              # Append the std of the subset

print('Average prices:      ', means)
print('Standard deviations: ', stds)
```
2.使用groupby以及agg()函数的普通形式
.groupby
``` python
price_means = data.groupby('segment')['price'].mean()        # groupby相当于把原数据按照unique的值分成了多个subset
price_means
segment
CCR    3.299744e+06
OCR    1.129063e+06
RCR    1.644209e+06
Name: price, dtype: float64
```
agg()可以同时使用多种算法 相当于.mean() .max() .min()等函数的集合
对于一个column用多个function
``` python
funs = ['count', 'median', 'max', 'min']
condo.groupby('segment')['price'].agg(funs)                  # groupby后面用的是() 不是[]

    count	 median	 max	    min
segment				
CCR	5107	2450000	52000000	560088
OCR	16652	1069590	4881708	488000
RCR	10409	1490000	19000000	570000

price_info.columns
Index(['count', 'median', 'max', 'min'], dtype='object')

price_info.index
Index(['CCR', 'OCR', 'RCR'], dtype='object', name='segment')

# 可以把index转化成第一列 然后生成新的index
price_info.reset_index()                        # 但原dataset不变
  segment	count	  median	max	     min
0	CCR	    5107	2450000	52000000	560088
1	OCR	    16652	1069590	4881708	  488000
2	RCR	    10409	1490000	19000000	570000
```
3.使用def定义需要的function
例如要求四分位距 即0.75-0.25
``` python
def func(x):
    return x.quantile(0.75) - x.quantile(0.25)
condo.groupby('segment')['price'].agg(func)    # 注意这里把用function的那一列写在前面 func后面不加()了
segment
CCR    2010000
OCR     470000
RCR     708800
Name: price, dtype: int64
```
4.使用lambda简化function
typically used to return the result expressed by a single-line statement 单一行的计算结果
``` python
condo.groupby('segment')['price'].agg(lambda x : x.quantile(0.75) - x.quantile(0.25)).reset_index()
  segment	price
0	CCR	    2010000
1	OCR	    470000
2	RCR	    708800
```
**单一column分组 多个column用function**
``` python
funs = ['count', 'median', 'max', 'min']
f = condo.groupby('segment')[['price','unit_price']].agg(funs)
f
    price	                          unit_price
    count	median	max	min	          count	median	max	min
segment								
CCR	5107	2450000	52000000	560088	5107	1937	4913	684
OCR	16652	1069590	4881708	488000	16652	1078	2285	485
RCR	10409	1490000	19000000	570000	10409	1560	2908	597

f.columns
MultiIndex([(     'price',  'count'),
            (     'price', 'median'),
            (     'price',    'max'),
            (     'price',    'min'),
            ('unit_price',  'count'),
            ('unit_price', 'median'),
            ('unit_price',    'max'),
            ('unit_price',    'min')],
           )
           
f.index
Index(['CCR', 'OCR', 'RCR'], dtype='object', name='segment')

# 同样可以把index转化成第一列 然后生成新的index
a.reset_index()
 segment price	            unit_price
      count	median	max	min	count	median	max	min
0	CCR	5107	2450000	52000000	560088	5107	1937	4913	684
1	OCR	16652	1069590	4881708	488000	16652	1078	2285	485
2	RCR	10409	1490000	19000000	570000	10409	1560	2908	597
```
**单一column分组 多个column用不同的function**  
用dictionary 不同的column对应不同的function
``` python
d = {'price':['max','min'],
     'unit_price':['count','mean']}               # 注意这里前面的key只能是单一值 不能是[‘xx’,‘xx’]
condo.groupby('segment').agg(d).reset_index()
  segment	price	        unit_price
       max	    min	    count	mean
0	CCR	52000000	560088	5107	2047.080674
1	OCR	4881708	488000	16652	1098.835275
2	RCR	19000000	570000	10409	1544.190220
```
**多个column分组**
简单方法可以参考pivot_table
Explore the percentage of survival by sex and classes.
``` python
d = data_titan.groupby(['sex','class'])['survived'].mean()
d
sex     class 
female  First     0.968085
        Second    0.921053
        Third     0.500000
male    First     0.368852
        Second    0.157407
        Third     0.135447
Name: survived, dtype: float64

d.index            # 两层index row indices of the series above have two layers, containing all combinations of values of sex and class.
MultiIndex([('female',  'First'),
            ('female', 'Second'),
            ('female',  'Third'),
            (  'male',  'First'),
            (  'male', 'Second'),
            (  'male',  'Third')],
           names=['sex', 'class'])
```


### transformation 行数永远和原数据的行数一样
例如把每个值normalize 标准化处理 去除量纲dimension 使不同数量级scale的数据能够比较
``` python
# def
def func(x):
    return (x - x.min()) / (x.max() - x.min())
condo.groupby('segment')['price'].transform(func)
# 或者lambda
condo.groupby('segment')['price'].transform(lambda x : (x - x.min()) / (x.max() - x.min()))
0        0.074415
1        0.039609
2        0.288367
3        0.082203
4        0.069392
           ...   
32163    0.177527
32164    0.076473
32165    0.173430
32166    0.135193
32167    0.027767
Name: price, Length: 32168, dtype: float64
```
### apply
apply既可以当成agg也可以当成transform 根据后面的函数来定 但是一般不用 因为不明确
``` python
price_iqr = data.groupby('segment')['price'].apply(lambda x: 
                                                   x.quantile(0.75) - x.quantile(0.25))

price_norm = data.groupby('segment')['price'].apply(lambda x: 
                                                    (x-x.min())/(x.max()-x.min()))
```



## 数据透视表 Pivot table 
Explore the percentage of survival by sex and classes.
``` python
d = data_titan.pivot_table('survived', columns='class', index='sex')
d           # 这里可以参考agg里面的多个column分组 简化写法
class	First	        Second	        Third
sex			
female	0.968085	0.921053	0.500000
male	0.368852	0.157407	0.135447

d.index.name = None   # 把index和column的名字删去
d.columns.name = None
d
        First	        Second	        Third
female	0.968085	0.921053	0.500000
male	0.368852	0.157407	0.135447
```
index也可以是multi layer
``` python
d = data_titan.pivot_table('survived', index=[age, 'sex'], columns='class') 
# 注意这里的age都不是dataframe中的一列 是独立的variable 默认一一对应起来了
```
![image](https://user-images.githubusercontent.com/105503216/171981570-d42874ad-a548-4439-a5f0-113061ea748a.png)
